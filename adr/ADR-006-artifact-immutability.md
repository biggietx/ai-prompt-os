# ADR-006: Artifact Immutability

## Status

Accepted

## Date

2026-02-20

## Context

PromptOS v0.5.0 established mandatory artifact validation at the Orchestrator's approval boundary. Gate 06 now rejects governed runs that lack a valid `prompt_session.json`. This ensures that prompt governance is recorded. But recording alone is insufficient — the record must also be trustworthy.

A session artifact that can be modified after creation undermines the governance it claims to provide. Consider the scenario: a developer runs a governed session using only P05 (implementation), skipping P06 (verification) and P07 (review). The resulting `prompt_session.json` correctly records that only P05 was used. Before submitting for approval, the developer edits the JSON to add P06 and P07 to the `prompts_used` array. Gate 06 validates the artifact, finds all expected prompts listed, and approves the run. The separation of duties that PromptOS is designed to enforce has been silently bypassed.

This is not a hypothetical attack. It is the natural consequence of any governance system where artifacts are mutable and unverified. The artifact becomes a form to fill out rather than a record of what happened. The fix is straightforward: make artifacts tamper-detectable by recording their cryptographic hash at creation time and verifying it at validation time.

## Decision

### SHA-256 Hash Generation at Recording Time

When `session/record_session.sh` writes a session JSON file, it now immediately computes the SHA-256 hash of that file and writes it to an adjacent `.sha256` sidecar file. The sidecar follows the BSD/GNU checksum format:

```
<hash>  <filename>
```

The hash is computed at the same moment the artifact is created, before the developer has any opportunity to modify it. This establishes the artifact's integrity baseline. Any subsequent modification — adding prompts, changing the developer name, altering the timestamp — will change the file's hash and be detectable.

SHA-256 is chosen for several reasons:

- It is universally available via `shasum` on macOS and Linux without additional dependencies.
- It provides sufficient collision resistance for artifact integrity verification (this is not a cryptographic signing use case where adversarial collision attacks are a concern).
- The hash format is human-readable and can be verified manually with standard command-line tools.

### Hash Verification at Validation Time

The validation script (`scripts/validate_prompt_artifact.sh`) now includes a hash verification step after schema validation. When validating `prompt_session.json`, it:

1. Checks for the existence of `prompt_session.sha256` in the same directory.
2. Reads the expected hash from the `.sha256` file.
3. Computes the actual SHA-256 hash of `prompt_session.json`.
4. Compares the two hashes.

If the `.sha256` file is missing, validation fails with: "Hash file missing. Artifact immutability cannot be verified." This prevents a bypass where a developer deletes the hash file to avoid detection.

If the hashes do not match, validation fails with: "Artifact hash mismatch. Possible tampering detected." This is a hard failure — the governed run cannot proceed. The error message includes both the expected and actual hashes, allowing investigation.

If the hashes match, validation succeeds with: "Artifact hash verified." This provides positive confirmation that the artifact has not been modified since creation.

### Export Chain Integrity

The export script (`session/export_session_artifact.sh`) now copies both the session JSON and its `.sha256` sidecar file into the artifacts directory. This ensures that the hash travels with the artifact through the entire pipeline — from creation in `session/logs/` to the Orchestrator's evidence directory. The hash file in the artifacts directory is named `prompt_session.sha256`, matching the artifact naming convention.

This creates a complete integrity chain:

1. Session is recorded → JSON + hash are created simultaneously.
2. Session is exported → both files are copied to the artifacts directory.
3. Artifact is validated → hash is verified against the file.

At no point in this chain does the artifact exist without its integrity proof.

### Threat Model

This design addresses the following threats:

**Post-hoc modification**: A developer edits the session JSON after creation to misrepresent which prompts were used. Detection: hash mismatch at validation time.

**Selective artifact creation**: A developer manually creates a fake `prompt_session.json` without using the recording system. Detection: no corresponding `.sha256` file (the hash is only generated by the recording script). Even if a developer generates their own hash for a fake artifact, the act of fabricating both files is a deliberate fraud that leaves forensic traces (timestamp inconsistencies, missing git history).

**Hash file deletion**: A developer deletes the `.sha256` file to avoid hash verification. Detection: validation explicitly fails when the hash file is missing, rather than silently skipping verification.

**Artifact substitution**: A developer replaces a session artifact with one from a different session. Detection: the hash of the replacement file will not match the original `.sha256` file.

### Limitations

This is integrity verification, not cryptographic signing. The hash proves the file has not changed since the hash was computed, but it does not prove who computed the hash or when. A determined attacker who controls the recording environment could generate a fake artifact with a matching hash. Full non-repudiation would require digital signatures with asymmetric keys, which introduces key management complexity beyond the current scope.

For PromptOS's governance model — where the primary threat is accidental or opportunistic modification rather than sophisticated adversarial attack — hash-based integrity verification provides the right balance of security and simplicity.

## Consequences

- **Positive**: Session artifacts become tamper-detectable. Any modification after creation produces a verifiable hash mismatch.
- **Positive**: Integrity verification uses only standard Unix tools (`shasum`), adding no new dependencies.
- **Positive**: The complete chain — create, export, validate — maintains integrity proof at every step.
- **Positive**: Missing hash files are treated as failures, preventing silent bypass of integrity checks.
- **Negative**: Hash verification does not provide non-repudiation (who created the artifact). Mitigation: combine with git commit signatures and Orchestrator run records for attribution.
- **Negative**: Hash files add a second file to manage alongside each artifact. Mitigation: export and validation scripts handle both files automatically; developers do not interact with hash files directly.
- **Negative**: Legitimate re-recording of a session (e.g., after correcting a mistake) requires generating a new artifact and hash pair. Mitigation: this is by design — re-recording should produce a new session with a new timestamp, not modify an existing one.
